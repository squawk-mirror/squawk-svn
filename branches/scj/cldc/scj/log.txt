
Memo:

- Allocating process: new -> GC.allocatePrim() -> BackingStore.allocate()

- Current allocating context is hold by BackingStore; VMThread has a field 
  called "savedAllocCtx", which is used to save the current allocating 
  context for the current thread which will be switched out immediately.

- Immortal and Scoped are seen as RAM during SCJ execution, so we put the 
  check in GC.inRam(Object) as well and return true if the object is in 
  Immortal or Scoped.

- ObjectAssociation / Monitor allocation - two choices:
  1) allocate along with the object - space wasting
  2) allocate upon required at the scope where the object is allocated 
     - overhead: search for and switch allocation context (done)

- Class state allocation - two choices:
  1) pre-allocate in immortal memory before user program starts to run 
  2) allocate upon required in immortal memory (done)
  
- Implementing BackingStore.getBackingStore(Object) in an efficient
  way; for now it is done by simply searching for the BS enclosing the 
  address of the object. The search time can be decreased by:
  1) add BS pointer to object header
  2) make BS organization support binary search. (done)     
  
- A timer super thread is added for improving the reschedule granularity on 
  Mac OS platform. The timer periodically decreases the slept time of the
  TimerQueue by one tick until it reaches zero, which denotes at least
  one thread needs to be waken up. At that point, poll word is set, which
  will be checked at next call to pollCheck function. If the poll word is set,
  reschedule is performed.
  
  The "tick" can be adjusted but not set too small due to the overhead. So the
  reschedule granularity largely depends on how frequent the pollCheck is 
  called. The ideal way is to insert pollCheck at back branch and function
  entry point. However, doing pollCheck during VM kernel execution often
  leads to crash. 
  
  [[!!
    Unless we get a way to disable pollCheck when running in kernel, our 
  	approach does NOT work. 
  !!]]
  
- Scope checks: we need to do scope check when assigning one object to another's
  field for making sure no object references objects located in shorter living BSs.
  The scope check for (obj1.f = obj2) is done in this way:
    - fast path: if addressOf(obj1) > addressOf(obj2), OK; 
                 else slow path
    - slow path: if BSof(obj1) == BSof(obj2), OK; 
                 else FAIL.

  The scope check is done as a write barrier along with updating reference 
  operation. For now, all reference updates are checked. However, we want
  a way to disable scope check for some updates, because sometimes scope
  rule has to be violated in implementation. e.g. when manipulating BS 
  pointers must not be check as the BS structures is in an inconsistent status
  during then. And, to implementing portal for scoped memory will definitely 
  violate scope rule.
  
  The current way to disable scope check is simple, inefficient, and not
  thread safe: a static field, BackingStore.scopeCheckEnabled, is used as
  a switch, so for every assignment which is not supposed to be checked, one
  needs to surround it with BackingStore.disableScopeCheck()/enableScopeCheck()
  pair(, which is kind of ugly). 
  
  An ideal way would be to have a new annotation denoting whether a method or
  assignment expression should be checked or not. This causes the unnecessary
  check removed statically, which is still simple, no harm to performance, and
  not related to threading issue.   
  
  [[!!
    We MUST: 
      1) disable all illegal assignments that are known to be safe. An illegal
         assignment is safe if all the references to a short live object will
         be explicitly nulled before the object dies. One example includes the
         hash tables used in Squawk. When an item becomes is dying, the entry
         will be removed explicitly so no dangling pointer will come up. We must
         be really careful to disable a check. We cannot disable it unless we
         are sure the assignment is safe in any cases.
      2) throw IllegalAssignmentError for the rests 
  !!]]  
  
  The currently known illegal assignments (just some of them have been disabled
  check.):
  
    * All of the static fields
        If the value is globally needed, should switch to immortal when allocating. 
        If temporarily needed (will not be read after the object dies), should 
        disable scope check for assignment.  
  
    * Mission.manager = MissionManager 
        Does not cause error. Scope check should be disabled.
      
    * Klass.klassToClass.entry = HashtableEntry
        The Class instance can be created lazily potentially everywhere but will 
        be cached in the hash table. This cause uncertainty of the assignment.
        
        Update: the creation of the hash table and entries has been made to happen
        in immortal. 
      
    * Assign to Timer.next / Timer.prev / TimerThead.head
        Timers are linked together. While most of the timers will be created in 
        mission memory, the NeverFireTimer is created in immortal. Trying to link
        them will cause illegal assignment, but will not cause error, because when
        a timer instance is about to die, it will be detached from the queue. 
      
    * Assign to VMThread.currentThread / VMThread.otherThread
        VMThread instances can be created in scopes. When finishing running, they
        should be removed somehow from these two references. Seems to be not going
        to cause error. Need to check more ...
  
    * ThreadQueue <- VMThread
     
    * Monitor <- VMThread
    
    * IntHashtable / EventHashtable
        IntHashtable   VM.keyeGlobals
        EventHashtable VMThread.events
        EventHashtable VMThread.osevents
        
        It is generally safe to disable scope check for put() since the entry is 
        allocated when needed and removed when not. rehash() is bad in the sense
        that 1) it leaves the old table as garbage; 2) the new table will be 
        allocated in "current" scope which may be short lived.  
        
     * SquawkHashtable
     
       non-static reference:
       
       Isolate.monitorHashtable
       Isolate.internedStrings
       Isolate.childIsolates;
       Isolate.childThreads
       Isolate.mailboxAddresses
       Isolate.mailboxes
       Isolate.properties
       PeripheralRegistry.peripheralArraysByType
       Hashtable.delegate
       
       static reference:
         
       GC.heapstats
       Klass.klassToClass
       NativeUnsafe.unresolvedClassPointers
       VM.registeredMailboxes
       ComputationTimer.flatTimes
       ComputationTimer.totalTimes
       Tracer._features
       
       
    
- A limitation of SCJ Timer: simply ignores the clock field; assumes all time 
  are according to the realtime clock (get by calling Clock.getRealtimeClock()).
  This compromise simplifies the implementation: only one timer queue needs to 
  be maintained. The queue is sorted based on the target time of the timers. 
  For supporting other user defined clocks, one queue per clock is needed.


- Garbage in Immortal
  
  There are certainly temporary objects allocated in immortal memory during VM 
  starts up. Ideally, we should use object pool. But for now, just let it be 
  while keeping a list of what they are (not complete, will add more when found):
  
  KlassInitializationState
  entry of SquawkHashtable Isolate.childThreads
  
  


TODO:

  [[!!
    IMPORTANT: we must fully know what a method does if we need to call them in 
    scoped memory, because a method can potentially:
      1) allocating (which means leaking memory under GC-absent environment)
      2) doing illegal assignments  
    For 1), we must make sure the allocation is necessary and user-awared;
    For 2), make sure no dangling pointer will actually occur and annotate it.
  !!]]



- Add SCJ options to builder

  For now, we start the SCJ instead of Midlet launcher simply by replacing 
  the original value of Isolate.MIDLET_WRAPPER_CLASS with 
  com.sun.squawk.scj.SafeletLauncher. And also, the Safelet class name is 
  hard coded in SafeletLauncher. We may want to do the SCJ startup process 
  more elegantly by extending the builder ...


- Memory leak in immortal

  There should be a lot of methods leaking memory if no GC. Who are they?
  
  Need to check what data structures have been allocated dynamically. On 
  high level, we must make sure those data structures are of proper life 
  time and allocated in the proper scope, otherwise we have memory leak. 
  
  Known leaking:
  
    * IOHander
        A regular Java thread which is started along with the VM and blocked
        until a certain thread gets involved in some IO activities. At that
        conjunction, IOHander gets switched back in and in turn set the
        immortal as the allocation context (which is where it was switched 
        out). Apparently, any following allocation done by IOHandler cause 
        leak in immortal unless the created objects are intended to be kept 
        permanently. 
  

- Monitor object allocations are triggered when printing. Check why??


- Scheduling performance improvement:
  - separated priority queue?
  - delta timer queue?
  - RTC interrupted rescheduling?
  
  Solution:
    - the sleeping thread queue is maintained as a delta queue (dQ); the unit of 
      delta is "tick"
    - a timer (ISR or supervisor thread) decrease the dQ.head by one tick. If 
      dQ.head == 0, set reschedule word
    - at poll check,
        if reschedule word set, do reschedule
  

- Priority Ceiling Emulation Implementation


- Need to have priority levels >= 28


- Exception handling

  the exception object is still allocated in the scope where the exception
  happens. SCJ instead requires to allocate in a dedicated thread local 
  space, which we do not have yet for now.
 
 
- Support to sleep until certain absolute time 
    
  RealtimeThread.sleep(HighResolutionTime) and HighResolutionTime.wait(Object, 
  HighResolutionTime) will do absolute sleep / wait, when getting an AbsoluteTime
  as parameter. We don't want to compute the delta to the current time by ourself 
  and call Thread.sleep(delta) since the error may accumulate. Just tell the VM
  when we want to wake up and let it do the math in an efficient way, e.g in native
  code or by utilizing some OS/hardware support if there are some. 


- Translate BackingStore.allocate() to C

  Otherwise, object allocation would be 20x slower.
    
  
- Test, Test, Test ! 


- Example, Example, Example !


