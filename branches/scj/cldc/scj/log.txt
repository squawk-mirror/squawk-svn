
Memo:

- Allocating process: new -> GC.allocatePrim() -> BackingStore.allocate()

- Current allocating context is hold by BackingStore; VMThread has a field 
  called "savedAllocCtx", which is used to save the current allocating 
  context for the current thread which will be switched out immediately.

- Immortal and Scoped are seen as RAM during SCJ execution, so we put the 
  check in GC.inRam(Object) as well and return true if the object is in 
  Immortal or Scoped.

- ObjectAssociation / Monitor allocation - two choices:
  1) allocate along with the object - space wasting
  2) allocate upon required at the scope where the object is allocated 
     - overhead: search for and switch allocation context (done)

- Class state allocation - two choices:
  1) pre-allocate in immortal memory before user program starts to run 
  2) allocate upon required in immortal memory (done)
  
- Need to implement BackingStore.getBackingStore(Object) in a more efficient
  way; for now it is done by simply line searching for the BS enclosing the 
  address of the object. The search time can be decreased by:
  1) add BS  pointer to object header
  2) make BS organization support binary search. (done)     
  
- A timer super thread is added for improving the reschedule granularity on 
  Mac OS platform. The timer periodically decreases the slept time of the
  TimerQueue by one tick until it reaches zero, which denotes at least
  one thread needs to be waken up. At that point, poll word is set, which
  will be checked at next call to pollCheck function. If the poll word is set,
  reschedule is performed.
  
  The "tick" can be adjusted but not set too small due to the overhead. So the
  reschedule granularity largely depends on how frequent the pollCheck is 
  called. The ideal way is to insert pollCheck at back branch and function
  entry point. However, doing pollCheck during VM kernel execution often
  leads to crash. 
  
  [[!!
    Unless we get a way to disable pollCheck when running in kernel, our 
  	approach does NOT work. 
  !!]]
  
  

TODO:

- For now, we start the SCJ instead of Midlet launcher simply by replacing 
  the original value of Isolate.MIDLET_WRAPPER_CLASS with 
  com.sun.squawk.scj.SafeletLauncher. And also, the Safelet class name is 
  hard coded in SafeletLauncher. We may want to do the SCJ startup process 
  more elegantly by extending the builder ...

- Need to check what data structures have been allocated dynamically. On 
  high level, we must make sure those data structures are of proper life 
  time and allocated in the proper scope, otherwise we have memory leak.  
  
- Add scope check for making sure no dangling pointer happened. This results 
  in the need of write barrier.
  
- Monitor object allocations are triggered when printing. Check why??

- Scheduling performance improvement:
  - separated priority queue?
  - delta timer queue?
  - RTC interrupted rescheduling?
  - more papers?
  
  Solution:
    - the sleeping thread queue is maintained as a delta queue (dQ); the unit of 
      delta is "tick"
    - a timer (ISR or supervisor thread) decrease the dQ.head by one tick. If 
      dQ.head == 0, set reschedule word
    - at poll check,
        if reschedule word set, do reschedule
  
- Priority Ceiling Emulation implementation

- Priority level: >=28 level, do we need system level priorities?