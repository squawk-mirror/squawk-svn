
Memo:

- Allocating process: new -> GC.allocatePrim() -> BackingStore.allocate()

- Current allocating context is hold by BackingStore; VMThread has a field 
  called "savedAllocCtx", which is used to save the current allocating 
  context for the current thread which will be switched out immediately.

- Immortal and Scoped are seen as RAM during SCJ execution, so we put the 
  check in GC.inRam(Object) as well and return true if the object is in 
  Immortal or Scoped.

- ObjectAssociation / Monitor allocation - two choices:
  1) allocate along with the object - space wasting
  2) allocate upon required at the scope where the object is allocated 
     - overhead: search for and switch allocation context (done)

- Class state allocation - two choices:
  1) pre-allocate in immortal memory before user program starts to run 
  2) allocate upon required in immortal memory (done)
  
- Implementing BackingStore.getBackingStore(Object) in an efficient
  way; for now it is done by simply searching for the BS enclosing the 
  address of the object. The search time can be decreased by:
  1) add BS pointer to object header
  2) make BS organization support binary search. (done)     
  
- A timer super thread is added for improving the reschedule granularity on 
  Mac OS platform. The timer periodically decreases the slept time of the
  TimerQueue by one tick until it reaches zero, which denotes at least
  one thread needs to be waken up. At that point, poll word is set, which
  will be checked at next call to pollCheck function. If the poll word is set,
  reschedule is performed.
  
  The "tick" can be adjusted but not set too small due to the overhead. So the
  reschedule granularity largely depends on how frequent the pollCheck is 
  called. The ideal way is to insert pollCheck at back branch and function
  entry point. However, doing pollCheck during VM kernel execution often
  leads to crash. 
  
  [[!!
    Unless we get a way to disable pollCheck when running in kernel, our 
  	approach does NOT work. 
  !!]]
  
- Scope checks: we need to do scope check when assigning one object to another's
  field for making sure no object references objects located in shorter living BSs.
  The scope check for (obj1.f = obj2) is done in this way:
    - fast path: if addressOf(obj1) > addressOf(obj2), OK; 
                 else slow path
    - slow path: if BSof(obj1) == BSof(obj2), OK; 
                 else FAIL.

  The scope check is done as a write barrier along with updating reference 
  operation. For now, all reference updates are checked. However, we want
  a way to disable scope check for some updates, because sometimes scope
  rule has to be violated in implementation. e.g. when manipulating BS 
  pointers must not be check as the BS structures is in an inconsistent status
  during then. And, to implementing portal for scoped memory will definitely 
  violate scope rule.
  
  The current way to disable scope check is simple, inefficient, and not
  thread safe: a static field, BackingStore.scopeCheckEnabled, is used as
  a switch, so for every assignment which is not supposed to be checked, one
  needs to surround it with BackingStore.disableScopeCheck()/enableScopeCheck()
  pair(, which is kind of ugly). 
  
  An ideal way would be to have a new annotation denoting whether a method or
  assignment expression should be checked or not. This causes the unnecessary
  check removed statically, which is still simple, no harm to performance, and
  not related to threading issue.   

- A limitation of SCJ Timer: simply ignores the clock field; assumes all time 
  are according to the realtime clock (get by calling Clock.getRealtimeClock()).
  This compromise simplifies the implementation: only one timer queue needs to 
  be maintained. The queue is sorted based on the target time of the timers. 
  For supporting other user defined clocks, one queue per clock is needed.



TODO:

  [[!!
    IMPORTANT: we must fully know what a method does if we need to call them in 
    scoped memory, because a method can potentially:
      1) allocating (which means leaking memory under GC-absent environment)
      2) doing illegal assignments  
    For 1), we must make sure the allocation is necessary and user-awared;
    For 2), make sure no dangling pointer will actually occur and annotate it.
  !!]]


- For now, we start the SCJ instead of Midlet launcher simply by replacing 
  the original value of Isolate.MIDLET_WRAPPER_CLASS with 
  com.sun.squawk.scj.SafeletLauncher. And also, the Safelet class name is 
  hard coded in SafeletLauncher. We may want to do the SCJ startup process 
  more elegantly by extending the builder ...

- there should be a lot of methods leaking memory if no GC. Who are they?

- Need to check what data structures have been allocated dynamically. On 
  high level, we must make sure those data structures are of proper life 
  time and allocated in the proper scope, otherwise we have memory leak.  
  
- Monitor object allocations are triggered when printing. Check why??

- Scheduling performance improvement:
  - separated priority queue?
  - delta timer queue?
  - RTC interrupted rescheduling?
  - more papers?
  
  Solution:
    - the sleeping thread queue is maintained as a delta queue (dQ); the unit of 
      delta is "tick"
    - a timer (ISR or supervisor thread) decrease the dQ.head by one tick. If 
      dQ.head == 0, set reschedule word
    - at poll check,
        if reschedule word set, do reschedule
  
- Priority Ceiling Emulation implementation

- Need to have priority levels >= 28

- the exception object is still allocated in the scope where the exception
  happens. SCJ instead requires to allocate in a dedicated thread local 
  space, which we do not have yet for now.
  
- A way to sleep until certain absolute time is needed. In order RealtimeThread.sleep(HighResolutionTime)

 