
Memo:

- Allocating process: new -> GC.allocatePrim() -> BackingStore.allocate()

- Current allocating context is hold by BackingStore; VMThread has a field called "savedAllocCtx", which is used 
  to save the current allocating context for the current thread which will be switched out immediately.
     
- All classes are pre-initialized in Immortal at SafeletLauncher.main() right before SCJ program starts to run

- Immortal and Scoped are seen as RAM during SCJ execution, so we put the check in GC.inRam(Object) as well and 
  return true if the object is in Immortal or Scoped.

TODO:

- For now, we start the SCJ instead of Midlet launcher simply by replacing the original value of Isolate.MIDLET_WRAPPER_CLASS 
  with com.sun.squawk.scj.SafeletLauncher. And also, the Safelet class name is hard coded in SafeletLauncher. We may want to
  do the SCJ startup process more elegantly by extending the builder ...

- Need to check what data structures have been allocated dynamically. On high level, we must make sure those data structures
  are of proper life time and allocated in the proper scope ...
  
- ObjectAssociation / Monitor allocation - two choices:
  1) allocate along with the object - overhead more space
  2) allocate upon required at the place where the object is allocated - overhead: search for and switch allocation context (chosen)

- Class state allocation - two choices:
  1) pre-allocate in immortal memory before user program starts to run (chosen)
  2) allocate upon required in immortal memory
