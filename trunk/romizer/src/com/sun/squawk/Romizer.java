/*
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.squawk;

import java.io.*;
import java.util.*;
import java.util.Arrays;
import java.util.jar.*;
import java.util.zip.*;
import javax.microedition.io.*;

import com.sun.squawk.util.*;
import com.sun.squawk.translator.*;
import com.sun.squawk.translator.ir.InstructionEmitter;
import com.sun.squawk.io.connections.ClasspathConnection;

/**
 * The romizer statically executes the translator over a set of classes
 * that are to be romized and then transfers the romized classes
 * from the host JVM's memory to an image file.
 */
public class Romizer {

    /**
     * The "build.properties" file.
     */
    protected static Properties buildProperties;
    
    private static String buildDotOverrideFileName;

    static String getBuildProperty(String key) {
        if (buildProperties == null) {
            initBuildProperties();
        }
        return buildProperties.getProperty(key);
    }
    
    static String getBuildProperty(String key, String ifNotThereValue) {
        if (buildProperties == null) {
            initBuildProperties();
        }
        return buildProperties.getProperty(key, ifNotThereValue);
    }
            
    /**
     * Reads the contents of the build properties.
     */
    protected static void initBuildProperties() {
        buildProperties = new Properties();
        FileInputStream inputStream = null;
        try {
            inputStream = new FileInputStream("build.properties");
            buildProperties.load(inputStream);
        } catch(IOException ex) {
            throw new Error("Could not find build.properties");
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
        try {
            if (buildDotOverrideFileName == null) {
                buildDotOverrideFileName = "build.override";
            }
            File overideProperties = new File(buildDotOverrideFileName);
            if (overideProperties.exists()) {

                // Make it very clear to the user which properties in the standard properties
                // file are potentially being overridden
                System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Using build override file: " + overideProperties.getPath() + " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                inputStream = new FileInputStream(overideProperties);
                buildProperties.load(inputStream);
            }
        } catch (IOException ex) {
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
    }

    static void putBuildProperty(String key, String value) {
        if (buildProperties == null) {
            initBuildProperties();
        }
        buildProperties.put(key, value);
    }
    
    /**
     * The name of the suite being romized.
     */
    private String suiteName;

    /**
     * The suite being romized.
     */
    private Suite suite;

    /**
     * The search path for classes in the suite.
     */
    private String classPath;

    /**
     * The Romizer instance used to create the parent of the suite being romized.
     */
    private Romizer parent;

    /**
     * The files generated by the romizer.
     */
    private Vector<String> generatedFiles = new Vector<String>();

    /**
     * Type of suite to create. This controls how much of the symbolic information is retained
     * in the suite when it is closed.
     */
    private int suiteType;

    /**
     * The class name patterns to be excluded as defined in an excludes files.
     */
    private Vector<String> excludes;

    /**
     * Specifies if the _classes.jar and _rt.jar files should be created.
     */
    private boolean createJars;

    /**
     * Specifies if the .suite.metadata file will be created.
     */
    private boolean createMetadata;
    
    /**
     * Specifies if the timing information should be displayed.
     */
    private static boolean timer;

/*if[J2ME.STATS]*/
    /**
     * Specifies if translation statistics should be gathered and printed.
     */
    private static boolean stats = false;
/*end[J2ME.STATS]*/

    /**
     * This is a prototype translator used to process and print translator options. It is not the translator used for translattion.
     */
    private TranslatorInterface protoTranslator;
    
    /**
     * Holds the name of the class that caused the last NoClassDefFoundError.
     */
    protected String lastClassName;
    
    protected List<String> noClassDefFoundErrorClasses = new ArrayList<String>();
    
    protected HashMap<String, String> jadProperties = new HashMap<String, String>();

    /**
     * This is the ObjectGraphLoader used when the -parent: option is used to specify the suite to load
     */
    protected ObjectGraphLoader objectGraphLoader;
    
    /**
     * Creates the romizer instance used to romize a suite.
     *
     * @param parent  the romizer that was used to romize the parent suite
     *                or null if this is the romizer creating the bootstrap suite
     */
    private Romizer(Romizer parent) {
        if (parent != null) {
            suiteType = parent.suiteType;
            this.parent = parent;
        } else {
            suiteType = Suite.LIBRARY;
        }
        protoTranslator = new Translator();
        objectGraphLoader = new ObjectGraphLoader();
    }


    /**
     * Prints the usage message.
     *
     * @param  errMsg  an optional error message
     */
    private void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println("**** " + errMsg + " ****");
        }
        
        out.println("Usage: romize [-options] classnames|dirnames|jarfiles...");
        out.println("where options include:");
        out.println();
        out.println("    -cp:<directories and jar/zip files separated by '"+File.pathSeparatorChar+"'>");
        out.println("                        paths where classes and sources can be found (required)");
        out.println("    -o:<name>           name of suite to generate (required)");
        out.println("    -boot:<name>        name of suite to to use for references to " + ObjectMemory.BOOTSTRAP_URI + " suite URL (default=file://squawk.suite)");
        out.println("    -parent:<name>      name of suite to use as the parent of the suite being built");
        out.println("    -jars               create <suite_name>_classes.jar which contains the class files");
        out.println("                        from which the suite was built");
        out.println("    -exclude:<file>     excludes classes that match the class names or packages");
        out.println("                        in file ('<name>.exclude' is used implicitly)");
        out.println("    -noclassdeffounderrorclass:<class name>    This class should cause a NoClassDefFoundError at runtime");
        out.println("    -endian:<value>     endianess ('big' or 'little') for generated suite (required)");
        out.println("    -arch:<name>        base name for dynamic compiler. Full name will be");
        out.println("                        \"com.sun.squawk.compiler.<name>Compiler\"");
        out.println("    -override:<file>     file to use to override the build.properties file found locally, defaults to build.override");
        protoTranslator.printOptionProperties(out, true);
        out.println("    -strip:<t>          strip symbolic information according to <t>:");
        out.println("                           'd' - debug: retain all symbolic info");
        out.println("                           'a' - application: discard all symbolic info");
        out.println("                           'l' - library (default): discard symbolic info");
        out.println("                                 for private/package-private fields and methods");
        out.println("                           'e' - extendable library: discard symbolic info");
        out.println("                                 for private fields and methods");
        out.println("    -lnt                retain line number tables");
        out.println("    -lvt                retain local variable tables");
        out.println("    -timer             print various phase timing statistics");
        out.println("    -verbose, -v     provide more output while running");
        out.println("    -stats              print various translation statistics");
        out.println("    -traceimage         trace building of ROM image");
        
        protoTranslator.printTraceFlags(out);
        
        if (Klass.TRACING_ENABLED) {
            out.println("    -tracestripping       trace stripping of symbolic information from suite");
            out.println("    -traceoms           trace object memory serialization");
            out.println("    -traceswapper       trace endianess swapping");
        }
        
        out.println("    -help               show this help message and exit");
        out.println();
        out.println();
        out.println("More than one suite can be created by separating the arguments for each");
        out.println("suite with '--'. For example:");
        out.println();
        out.println("  romize -o:squawk -cp:cldc/j2meclasses cldc/j2meclasses -- -cp:translator/j2meclasses -o:translator translator/j2meclasses");
        out.println();
    }

    /**
     * Processes a file with specifications of classes to exclude from the romizing process.
     * Each line in the file may be guarded with a property whose value is determined from
     * 'build.properties'.
     *
     * @param file     the file of exclude specifications
     * @return the read in specifications
     */
    private Vector<String> readExcludesFile(String file) {
        Vector<String> lines = new Vector<String>();
        ArgsUtilities.readLines(file, lines);

        Vector<String> excludes = new Vector<String>(lines.size());
        for (String line : lines) {
            line = line.trim();
            if (line.length() == 0 || line.startsWith("#")) {
                continue;
            }
            int index = line.indexOf(' ');
            if (index != -1) {
                // This is an exclusion predicated on a build property
                String predicate = line.substring(0, index);
                line = line.substring(index+1);
                String value = "false"; // The default value where there is not '='.
                index = predicate.indexOf('=');
                if (index != -1) {
                    value = predicate.substring(index+1);
                    predicate = predicate.substring(0, index);
                }
                if (!getBuildProperty(predicate, "false").equals(value)) {
                    continue;
                }
                while (line.charAt(0) == ' ') { // remove any extra spaces
                    line = line.substring(1);
                }
            }
            excludes.addElement(line);
		}
        return excludes;
    }

    /**
     * Commmand line interface.
     *
     * @param args
     */
    public static void main(String args[]) throws IOException {
        Romizer romizer = null;
        List<String> classNames = new ArrayList<String>();
        String[] argsLeft = args;
        while (true) {
	        try {
	            String[] newArgsLeft = new String[argsLeft.length + classNames.size()];
	            System.arraycopy(argsLeft, 0, newArgsLeft, classNames.size(), argsLeft.length);
	            argsLeft = newArgsLeft;
	            int i = 0;
	            for (String className: classNames) {
	            	argsLeft[i++] = "-noclassdeffounderrorclass:" + className;
	            }
		        while (argsLeft != null) {
		            romizer = new Romizer(romizer);
		            argsLeft = romizer.run(argsLeft);
		        }
		        return;
	        } catch (NoClassDefFoundError e) {
	        	if (romizer != null && romizer.getLastClassName() != null) {
	            	classNames.add(romizer.getLastClassName());
	            	System.out.println("   " + e.getClass().getSimpleName() + ": " + romizer.getLastClassName());
	            	if (VM.isVerbose()) {
	            		System.out.println("    " + e .getMessage());
	            	}
	                continue;
	        	}
	        	throw e;
	        }
        }
    }
    
    /**
     * Runs this instance of the romizer to produce a single suite.
     *
     * @param args  the arguments specifying the options and components of the suite
     * @return the remaining command line arguments after a "--" argument specifying subsequent suites or null
     *         if there are none
     */
    private String[] run(String[] args) {

        if (args.length == 0) {
            usage(null);
            return null;
        }
        try {
            args = ArgsUtilities.expandArgFiles(args);
            final Vector<String> classNames = new Vector<String>();
            final Vector<ResourceFile> resources = new Vector<ResourceFile>();
            args = processSuiteArgs(args, classNames, resources);
            if (args == null && suite == null) {
                return null;
            }

            // Load and translate the classes in the suite
            ComputationTimer.time("translating", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    translate(classNames);
                    return null;
                }
            });
            // Install resources found
            for (int i=0, maxI=resources.size(); i < maxI; i++) {
                ResourceFile resourceFile = (ResourceFile) resources.elementAt(i);
                if (VM.isVerbose()) {
                    System.out.println("[Including resource: " + resourceFile.name + "]");
                }
                suite.installResource(resourceFile);
            }
            // Install the jad properties passed on the command line
            for (String key: jadProperties.keySet()) {
            	String value = jadProperties.get(key);
            	suite.setProperty(key, value);
            }
            
            // Create the image file for the suite
            ComputationTimer.time("suite file creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createImage();
                    return null;
                }
            });

            if (suite.getParent() == null) {
                // Create the header file for the C implementation of the Squawk interpreter
                ComputationTimer.time("rom header creation", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        createCHeader();
                        return null;
                    }
                });
            }

            ComputationTimer.time(suiteName + ".api creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createSuiteAPI();
                    return null;
                }
            });
            if (timer) {
                ComputationTimer.dump(System.out);
                ComputationTimer.reset();
            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        }

/*if[J2ME.STATS]*/
        if (stats) {
/*if[DEBUG_CODE_ENABLED]*/
            KlassMetadata.Debug.printStats(System.out);
/*end[DEBUG_CODE_ENABLED]*/
            com.sun.squawk.translator.ir.InstructionEmitter.printStats();
        }
/*end[J2ME.STATS]*/

        System.out.println("Romizer processed " + suite.getClassCount() + " classes and generated these files:");
        for (String name : generatedFiles) {
            System.out.println("  " + name);
		}

        return args;
    }

    /**
     * Parses and processes a given set of command line arguments to translate a single suite.
     *
     * @param   args        the command line arguments
     * @param   classNames  a vector to collect the names of the classes to be translated
     * @param   Vector<ResourceFile> resources  a vector to collect the resources to be included
     * @return  the remaining command line arguments specifying a subsequent suite or null
     * @throws RuntimeException if the arguments are malformed
     */
    private String[] processSuiteArgs(String[] args, Vector<String> classNames, Vector<ResourceFile> resources) {
        int argc = 0;
        String excludeFile = null;

        Suite parentSuite = parent == null ? null : parent.suite;
        String key = null;
        while (argc != args.length) {
            String arg = args[argc];

            if (arg == null || arg.charAt(0) != '-') {
                break;
            } else if (arg.startsWith("-cp:")) {
                classPath = ArgsUtilities.toPlatformPath(arg.substring("-cp:".length()), true);
            } else if (arg.startsWith("-exclude:")) {
                excludeFile = arg.substring("-exclude:".length());
            } else if (arg.startsWith("-noclassdeffounderrorclass:")) {
                noClassDefFoundErrorClasses.add(arg.substring("-noclassdeffounderrorclass:".length()));
            } else if (arg.startsWith("-o:")) {
                suiteName = arg.substring("-o:".length());
            } else if (arg.equals("-jars")) {
                createJars = true;
            } else if (arg.equals("-metadata")) {
                createMetadata = true;
            } else if (arg.startsWith("-endian:")) {
                String value = arg.substring("-endian:".length());
                if (value.equals("big")) {
                    VM.setIsBigEndian(true);
                } else if (value.equals("little")) {
                     VM.setIsBigEndian(false);
                } else {
                    usage("invalid endianess: " + value);
                    throw new RuntimeException();
                }
            } else if (arg.startsWith("-arch:")) {
                String arch = arg.substring("-arch:".length()).toUpperCase();
                putBuildProperty("ARCHITECTURE", arch);
            } else if (arg.startsWith("-strip:") || arg.startsWith("-prune:")) {
                char type = arg.substring("-strip:".length()).charAt(0);
                if (type == 'a') {
                    suiteType = Suite.APPLICATION;
                } else if (type == 'd') {
                    suiteType = Suite.DEBUG;
                } else if (type == 'l') {
                    suiteType = Suite.LIBRARY;
                } else if (type == 'e') {
                    suiteType = Suite.EXTENDABLE_LIBRARY;
                } else {
                    usage("invalid suite type: " + type);
                    throw new RuntimeException();
                }
            } else if (arg.equals("-lnt")) {
                MethodMetadata.preserveLineNumberTables();
            } else if (arg.equals("-lvt")) {
                MethodMetadata.preserveLocalVariableTables();
            } else if (arg.equals("-timer")) {
                timer = true;
            } else if (arg.equals("-stats")) {
                System.setProperty("translator.stats", "true");
/*if[J2ME.STATS]*/
                stats = true;
/*end[J2ME.STATS]*/
            } else if (arg.startsWith("-trace")) {
                if (arg.startsWith("-tracefilter:")) {
                    String optArg = arg.substring("-tracefilter:".length());
                    Tracer.setFilter(optArg);
                } else {
                    Tracer.enableFeature(arg.substring("-trace".length()));
                    if (arg.equals("-traceconverting")) {
                        Tracer.enableFeature("loading"); // -traceconverting subsumes -traceloading
                    }
                }
            } else if (arg.equals("-verbose") | arg.equals("-v")) {
                    System.setProperty("translator.verbose", "true");
                    VM.setVerbose(true);
            } else if (arg.startsWith("-h")) {
                usage(null);
                return null;
            } else if (arg.startsWith("-boot:")) {
                String suiteName = arg.substring("-boot:".length());
                String suiteUrl = "file://" + suiteName + Suite.FILE_EXTENSION;
                System.setProperty(ObjectMemory.BOOTSTRAP_URI_PROPERTY, suiteUrl);
                try {
                    parentSuite = objectGraphLoader.loadSuite(suiteUrl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                System.setProperty("bootstrap.suite.url", suiteUrl);
            } else if (arg.startsWith("-parent:")) {
                String suiteName = arg.substring("-parent:".length());
                String suiteUrl = "file://" + suiteName + Suite.FILE_EXTENSION;
                try {
                    parentSuite = objectGraphLoader.loadSuite(suiteUrl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            } else if (arg.startsWith("-suitepath:")) {
                String path = arg.substring("-suitepath:".length());
                ObjectMemoryLoader.setFilePath(path);
                
            } else if (arg.startsWith("-nobuildproperties")) {
                if (buildDotOverrideFileName != null) {
                    throw new RuntimeException("Can't specify both -nobuildproperties and -override:");
                }
                buildProperties = new Properties();
            } else if (arg.startsWith("-override:")) {
                if (buildProperties != null) {
                    throw new RuntimeException("Can't specify both -nobuildproperties and -override:");
                }
	        	buildDotOverrideFileName = arg.substring("-override:".length());
            } else if (arg.startsWith("-key:")) {
            	key = arg.substring("-key:".length());
            } else if (arg.startsWith("-value:")) {
            	if (key == null) {
            		throw new RuntimeException("Did not specify a key for " + arg);
            	}
            	String value = arg.substring("-key:".length());
            	jadProperties.put(key, value);
            } else if (!protoTranslator.processOption(arg)) {
                usage("Unknown option "+arg);
                throw new RuntimeException();
            }
            argc++;
        }

        if (suiteName == null) {
            usage("missing -o option");
            throw new RuntimeException();
        }

        if (classPath == null) {
            usage("missing -cp option");
            throw new RuntimeException();
        }

        if (suiteType == Suite.LIBRARY || suiteType == Suite.EXTENDABLE_LIBRARY) {
            File file = new File(suiteName + "." + (suiteType == Suite.LIBRARY ? "library" : "extendable.library") + ".properties");
            if (file.exists()) {
                VM.resetSymbolsStripping(file);
            }
        }

        // Parse class name args (if any)
        while (argc != args.length) {
            String classArg = args[argc++];
            if (classArg.equals("--")) {
                break;
            }
            ArgsUtilities.processClassArg(ArgsUtilities.toPlatformPath(classArg, false), classNames, resources);
        }

        if (!classNames.isEmpty()) {
            if (excludeFile == null && new File(suiteName + ".exclude").exists()) {
                excludeFile = suiteName + ".exclude";
            }
            if (excludeFile != null) {
                excludeClasses(classNames, excludeFile);
            }
            suite = new Suite(suiteName, parentSuite);
            for (String className: noClassDefFoundErrorClasses) {
            	if (suite.shouldThrowNoClassDefFoundErrorFor(className)) {
            		noClassDefFoundErrorClasses.remove(className);
            	}
            }
            suite.addNoClassDefFoundErrorClassNames(noClassDefFoundErrorClasses.toArray(new String[noClassDefFoundErrorClasses.size()]));
        } else {
            usage("missing class names for suite " + suiteName);
            throw new RuntimeException();
        }

        // Return the remaining args that specify a subsequent suite (if any)
        if (argc != args.length) {
            String[] newArgs = new String[args.length - argc];
            System.arraycopy(args, argc, newArgs, 0, newArgs.length);
            return newArgs;
        } else {
            return null;
        }
    }

    /**
     * Strips classes from a list of class names based on an excludes file.
     *
     * @param classNames   the list of class names to modifiy
     * @param excludeFile  the name of the excludes file to use
     */
    private void excludeClasses(Vector<String> classNames, String excludeFile) {

        // The exclusions are remembered in a field so that the generated
        // suite can be verified not to include any classes that should have been excluded
        excludes = readExcludesFile(excludeFile);

        Vector<String> filteredClassNames = new Vector<String>(classNames.size());
        boolean firstLoop = true;
        for (String className : classNames) {
            boolean include = true;
            for (String spec : excludes) {
                if (firstLoop) {
                    System.out.println("excluding: " + spec);
                }
                boolean isPrefix = spec.endsWith("*");
                if (isPrefix) {
                    spec = spec.substring(0, spec.length() - 1);
                }
                if (isPrefix ? className.startsWith(spec) : className.equals(spec)) {
                    include = false;
                    break;
                }
			}
            if (include) {
                filteredClassNames.addElement(className);
            }
            firstLoop = false;
		}

        classNames.removeAllElements();
        classNames.addAll(filteredClassNames);
    }

    /**
     * Loads and translates the classes in the suite.
     *
     * @param  classNames the names of the classes that are to be translated
     */
    private void translate(Vector<String> classNames) {
        if (classNames.isEmpty()) {
            throw new RuntimeException("No classes found for "+suite);
        }

        System.out.println("[translating "+suite+" ...]");

        VM.setCurrentIsolate(null);
        Isolate isolate = new Isolate(null, null, suite);
        VM.setCurrentIsolate(isolate);

        isolate.setTranslator(new Translator());
        TranslatorInterface translator = isolate.getTranslator();
        try {
	        translator.open(suite, classPath);
        	suite.addNoClassDefFoundErrorClassNames(noClassDefFoundErrorClasses.toArray(new String[noClassDefFoundErrorClasses.size()]));

	
	        // Sort the classes in order to make sure that regardless of what platform we are on
	        // the order of the classes will be the same
	        String[] sortedClassNames = new String[classNames.size()];
	        classNames.copyInto(sortedClassNames);
	        Arrays.sort(sortedClassNames, new Comparator<String>() {
	            public int compare(String object1, String object2) {
	                if (object1 == object2) {
	                    return 0;
	                }
	                return object1.compareTo(object2);
	            }
	        });
	        // Create classes for each class name
	        for (String className: sortedClassNames) {
	        	if (noClassDefFoundErrorClasses.indexOf(className) == -1) {
	        		Klass.getClass(className, false);
	        	}
	        }

	        // Compute the complete class closure.
	        translator.close(suiteType);
	        
        } catch (NoClassDefFoundError t) {
    		lastClassName = translator.getLastClassName();
        	throw t;
        }

        // Ensure no classes that were meant to be excluded have been included
        verifyExclusions(suite);

    }

    /**
     * Ensures that no classes that were meant to be excluded have been included in a given suite.
     * If an exclusion was violated, then a warning is sent to the console.
     *
     * @param suite  the suite to verify
     */
    private void verifyExclusions(Suite suite) {
        if (excludes != null) {
            for (int i = 0; i != suite.getClassCount(); ++i) {
                Klass klass = suite.getKlass(i);
                if (klass == null) {
                    continue;
                }

                String className = (String)klass.getInternalName();
                for (String spec : excludes) {
                    if (spec.endsWith("*") ? className.startsWith(spec.substring(0, spec.length() - 1)) : className.equals(spec)) {
                        System.err.println("**WARNING**: suite includes class '" + className + "' that is matched by exclusion spec '" + spec + "'");
                    }
				}
            }
        }
    }

    /*---------------------------------------------------------------------------*\
     *                             Image building                                *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the serialized object memory representing the classes in the translated suite.
     */
	private void createImage() throws IOException {

        // Open the map file.
        File file = new File(suiteName + ".sym");
        PrintStream symbols = VM.Streams[VM.STREAM_SYMBOLS] = new PrintStream(new FileOutputStream(file));
        generatedFiles.addElement(file.getAbsolutePath());

        GC.setAllocationEnabled(true);

        // Strip the symbols in the suite and close it.
        Suite strippedSuite = suite.strip(suiteType, suite.getName(), suite.getParent());
        strippedSuite.close();

        String url = "file://" + strippedSuite.getName() + Suite.FILE_EXTENSION;
        DataOutputStream dos = Connector.openDataOutputStream(url);

        // Save the (canonical) address at which the suite will be saved
        int memoryStart = NativeUnsafe.getMemorySize();

        // The boostrap suite has a special URI
        String uri = strippedSuite.getParent() == null ? ObjectMemory.BOOTSTRAP_URI : url;
        strippedSuite.save(dos, uri, VM.isBigEndian());
        generatedFiles.addElement(new File(strippedSuite.getName() + Suite.FILE_EXTENSION).getAbsolutePath());

        // Create the <suiteName>.metadata file of all the class files from which the suite was created
        if (createMetadata) {
            String metadataUrl = "file://" + strippedSuite.getName() + Suite.FILE_EXTENSION + Suite.FILE_EXTENSION_METADATA;
            DataOutputStream metadataDos = Connector.openDataOutputStream(metadataUrl);
            Suite metadataSuite = suite.strip(Suite.METADATA, suiteName + Suite.FILE_EXTENSION + Suite.FILE_EXTENSION_METADATA, strippedSuite);
            int memorySizePrior = NativeUnsafe.getMemorySize();
            ObjectMemory objectMemory;
            ObjectGraphSerializer.pushObjectMap();
            try {
            	objectMemory = metadataSuite.save(metadataDos, metadataUrl, VM.isBigEndian());
            } finally {
            	ObjectGraphSerializer.popObjectMap();
            }
            GC.unRegisterReadOnlyObjectMemory(objectMemory);
            NativeUnsafe.setMemorySize(memorySizePrior);
            GC.setAllocTop(Address.zero().add(memorySizePrior));
            generatedFiles.addElement(new File(strippedSuite.getName() + Suite.FILE_EXTENSION + Suite.FILE_EXTENSION_METADATA).getAbsolutePath());
        }

        // Create the <suiteName>_classes.jar file of all the class files from which the suite was created
        if (createJars) {
            String jarFilePath = suiteName + "_classes.jar";
            File jarFile = new File(jarFilePath);
            jarClasses(jarFile, strippedSuite);
            generatedFiles.addElement(jarFile.getAbsolutePath());
        }

        // Ensures that saving worked
        NativeUnsafe.setMemorySize(memoryStart);
        ObjectMemory memory = ObjectMemoryLoader.load(Connector.openDataInputStream(url), url, false).objectMemory;

        // Add a few symbols.
        VM.printNatives(symbols);
        symbols.println("PMR.ROM_SIZE=" + memory.getSize());
        symbols.println("PMR.ROM_SUITE_TABLE=" + memory.getRoot());
        symbols.println("PMR.REVERSE_PARAMETERS=" + (Translator.REVERSE_PARAMETERS ? 1 : 0));

        printGlobalVariables(symbols);
        printGlobalAddresses(symbols);
        printGlobalOops(symbols);
        
        symbols.close();
    }

	@SuppressWarnings("unchecked")
	private void printGlobalAddresses(PrintStream symbols) {
        Hashtable<String, Integer> globalAddrs = (Hashtable<String, Integer>) InstructionEmitter.getGlobalAddrVariables();
        symbols.println("ROM.GLOBAL.ADDR.COUNT="+globalAddrs.size());
        for (Map.Entry<String, Integer> entry : globalAddrs.entrySet()) {
            symbols.println("ROM.GLOBAL.ADDR." + entry.getValue() + "=" + entry.getKey());
        }
	}


    @SuppressWarnings("unchecked")
	private void printGlobalOops(PrintStream symbols) {
        Hashtable<String, Integer> globalOops = (Hashtable<String, Integer>) InstructionEmitter.getGlobalOopVariables();
        symbols.println("ROM.GLOBAL.OOP.COUNT="+globalOops.size());
        for (Map.Entry<String, Integer> entry : globalOops.entrySet()) {
            symbols.println("ROM.GLOBAL.OOP." + entry.getValue() + "=" + entry.getKey());
        }
	}


	@SuppressWarnings("unchecked")
	private void printGlobalVariables(PrintStream symbols) {
        Hashtable<String, Integer> globalInts = (Hashtable<String, Integer>) InstructionEmitter.getGlobalIntVariables();
        symbols.println("ROM.GLOBAL.INT.COUNT="+globalInts.size());
        for (Map.Entry<String, Integer> entry : globalInts.entrySet()) {
            symbols.println("ROM.GLOBAL.INT." + entry.getValue() + "=" + entry.getKey());
        }
	}

	/**
     * Return the name of the class that caused the last NoClassDefFoundError.
	 */
	protected String getLastClassName() {
		return lastClassName;
	}

	/**
     * Creates a jar file of all the class files from which a given suite was built.
     *
     * @param file   the jar file to create
     * @param suite  the suite to jar
     */
    private void jarClasses(File file, Suite suite) {
        try {
            FileOutputStream fos = new FileOutputStream(file);
            ZipOutputStream zos = new JarOutputStream(fos);
            ClasspathConnection classPath = (ClasspathConnection)Connector.open("classpath://" + this.classPath);
            for (int i = 0; i < suite.getClassCount(); i++) {
                Klass klass = suite.getKlass(i);
                if (klass.isSynthetic()) {
                    continue;
                }

                String classFilePath = klass.getName().replace('.', '/') + ".class";
                addFileToJar(zos, classPath, classFilePath);
            }
            zos.close();
        } catch (IOException e) {
            throw new RuntimeException("IO error creating jar file", e);
        }
    }

    /**
     * Adds a given file to a given jar file stream.
     *
     * @param zos        the jar stream
     * @param classPath  where to find the file
     * @param filePath   the path to the file
     * @throws IOException if there is an IO error
     */
    private void addFileToJar(ZipOutputStream zos, ClasspathConnection classPath, String filePath) throws IOException {
        byte[] data = classPath.getBytes(filePath);

        ZipEntry e = new ZipEntry(filePath);
        e.setTime(System.currentTimeMillis());
        zos.putNextEntry(e);
        zos.write(data);
        zos.closeEntry();
    }


    /*---------------------------------------------------------------------------*\
     *                           C header file generation                        *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the C header file required by the C implementation of the Squawk interpreter.
     *
     * @throws IOException if an IO error occurs
     */
    private void createCHeader() throws IOException {
        File headerFile = new File("vmcore/src/vm/rom.h");
        Properties symbols = new Properties();
        symbols.load(new FileInputStream(suiteName + ".sym"));

        if (CHeaderFileCreator.update(suite, headerFile, symbols)) {
            generatedFiles.addElement(headerFile.getAbsolutePath());
        } else {
            System.out.println(headerFile.getAbsolutePath() + " is already up to date");
        }
    }

    /*---------------------------------------------------------------------------*\
     *                           Create squawk_rt.jar                            *
    \*---------------------------------------------------------------------------*/

    /**
     * Generates a text file describing the components in the
     * suite that can be dynamically bound to.
     */
    private void createSuiteAPI() throws IOException {
        Suite suite = this.suite.strip(suiteType, this.suite.getName(), this.suite.getParent());
        File api = new File(suiteName + Suite.FILE_EXTENSION + Suite.FILE_EXTENSION_API);
        PrintStream out = new PrintStream(new FileOutputStream(api));
        suite.printAPI(out);
        generatedFiles.addElement(api.getAbsolutePath());
        out.close();
    }

}
